#include <windows.h>
#include <windowsx.h>
#include <d3d9.h>
#include <stdio.h>
#include <d3dx9.h>
#include <string>

// include the Direct3D Library file
#pragma comment (lib, "d3d9.lib")
#pragma comment (lib, "d3dx9.lib")

// global declarations
LPDIRECT3D9 d3d; // the pointer to our Direct3D interface
LPDIRECT3DDEVICE9 d3ddev; // the pointer to the device class
bool DeviceLost = false;
D3DPRESENT_PARAMETERS d3dpp;

FILE *destHeaderFile = NULL;
FILE *destSourceFile = NULL;

void LoadTexture(const char *szFileName);
void ScanDirectory(const char *szDir, bool bFirstDir);

int main(int argc, char **argv)
{
	std::string szSearchPath = "./Assets";
	std::string szDestFileName = "PackedTextures";

	std::string szDestSourceFileName = szDestFileName;
	szDestSourceFileName.append(".cpp");

	std::string szDestHeaderFileName = szDestFileName;
	szDestHeaderFileName.append(".h");

    d3d = Direct3DCreate9(D3D_SDK_VERSION); // create the Direct3D interface

    ZeroMemory(&d3dpp, sizeof(d3dpp));    // clear out the struct for use
    d3dpp.Windowed = TRUE;    // program fullscreen, not windowed
    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;    // discard old frames
    d3dpp.hDeviceWindow = NULL;    // set the window to be used by Direct3D
    d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;    // set the back buffer format to 32-bit

	d3dpp.BackBufferWidth = 640;
	d3dpp.BackBufferHeight = 480;

    // create a device class using this information and the info from the d3dpp stuct
    d3d->CreateDevice(D3DADAPTER_DEFAULT,
                      D3DDEVTYPE_HAL,
                      NULL,
                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                      &d3dpp,
                      &d3ddev);

	destSourceFile = fopen(szDestSourceFileName.c_str(),"w+t");
	destHeaderFile = fopen(szDestHeaderFileName.c_str(),"w+t");

	fprintf(destHeaderFile,"/*=====================================================\n\n");
	fprintf(destHeaderFile,"\t%s\n\n\tThis file was generated by TexturePacker.\n\n",szDestHeaderFileName.c_str());
	fprintf(destHeaderFile,"=====================================================*/\n\n");
	fprintf(destHeaderFile,"bool GetPackedTexture(const char *szFileName, unsigned char *&pPixels, int &nWidth, int &nHeight);\n\n");

	fprintf(destSourceFile,"/*=====================================================\n\n");
	fprintf(destSourceFile,"\t%s\n\n\tThis file was generated by TexturePacker.\n\n",szDestSourceFileName.c_str());
	fprintf(destSourceFile,"=====================================================*/\n\n");
	fprintf(destSourceFile,"#include \"%s\"\n#include <string.h>\n#include \"RTCode\\defines.h\"\n\n",szDestHeaderFileName.c_str());
	fprintf(destSourceFile,"bool GetPackedTexture(const char *szFileName, unsigned char *&pPixels, int &nWidth, int &nHeight)\n{\n\n");

	ScanDirectory(szSearchPath.c_str(),true);

	fprintf(destSourceFile,"\treturn false;\n\n}\n");

	fclose(destHeaderFile);
	fclose(destSourceFile);

    return 0;
}

void ProcessPotentialTexture(const char *szFileName)
{
	LPDIRECT3DTEXTURE9 pDXTexture=NULL;
	HRESULT hr = D3DXCreateTextureFromFileA(d3ddev,szFileName,&pDXTexture);

	if(SUCCEEDED(hr))
	{
		D3DSURFACE_DESC Desc;
		hr = pDXTexture->GetLevelDesc(0,&Desc);
		if(SUCCEEDED(hr))
		{
			D3DLOCKED_RECT LockedRect;
			hr = pDXTexture->LockRect(0,&LockedRect,NULL,D3DLOCK_READONLY);
			if(SUCCEEDED(hr))
			{
				printf("Processing %s, %ix%i...\n",&szFileName[2],Desc.Width,Desc.Height);
				fprintf(destSourceFile,"\tif(!stricmp(szFileName,\"%s\"))\n",&szFileName[2]);
				fprintf(destSourceFile,"\t{\n\t\tnWidth = %i;\n\t\tnHeight = %i;\n\t\tstatic unsigned int data[] = {",Desc.Width,Desc.Height);

				//write out the pixels
				unsigned int *pPixelsRow = (unsigned int*)LockedRect.pBits;
				for(int nIndexY = 0;nIndexY < Desc.Height; ++nIndexY)
				{
					for(int nIndexX = 0;nIndexX < Desc.Width; ++nIndexX)
					{
						fprintf(destSourceFile,"%uU,",pPixelsRow[nIndexX]);
					}
					pPixelsRow += LockedRect.Pitch / 4;
				}

				fprintf(destSourceFile,"0};\n\t\tpPixels = (unsigned char *)data;\n");
				fprintf(destSourceFile,"\t\treturn true;\n\t}\n\n");

				pDXTexture->UnlockRect(0);
			}
		}
		pDXTexture->Release();
	}
}

void ScanDirectory(const char *szDir, bool bFirstDir)
{
	char szBuffer[1024];
	GetCurrentDirectory(1024,szBuffer);

	std::string szSearchString = szDir;
	szSearchString.append("/");
	szSearchString.append("*.*");

	//first scan for all files in the dir and try to load them as textures
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;
	hFind = FindFirstFileEx( szSearchString.c_str(), FindExInfoStandard, &FindFileData, FindExSearchNameMatch, NULL, 0 );

	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			{
				std::string szFullFileName = szDir;
				szFullFileName.append("/");
				szFullFileName.append(FindFileData.cFileName);
				ProcessPotentialTexture(szFullFileName.c_str());
			}
		}
		while(FindNextFile(hFind,&FindFileData));
	}

	//next, scan for all directories and recurse
	hFind = FindFirstFileEx( szSearchString.c_str(), FindExInfoStandard, &FindFileData, FindExSearchLimitToDirectories, NULL, 0 );

	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
			   strcmp(FindFileData.cFileName,".") &&
			   strcmp(FindFileData.cFileName,".."))
			{
				//handle ifdef wrappers for packed textures
				if(bFirstDir)
				{
					//everyone gets the common assets, so nothing to do here
					if(!stricmp(FindFileData.cFileName,"Common"))
					{
						fprintf(destSourceFile,"\t//All the common assets, everyone gets these\n");
					}
					//all non final gets NonFinalCommon
					else if(!stricmp(FindFileData.cFileName,"NonFinalCommon"))
					{
						fprintf(destSourceFile,"\t//all the non final common assets\n#if FINALGAME == GAME_NONE\n\n");
					}
					//else make an ifdef based on the game name, cause its a game specific asset
					else
					{
						std::string szCapitalDir = FindFileData.cFileName;
						for(int nIndex = 0; nIndex < szCapitalDir.size(); ++nIndex)
						{
							if(szCapitalDir[nIndex] >= 'a' && szCapitalDir[nIndex] <= 'z')
							{
								szCapitalDir[nIndex] = szCapitalDir[nIndex] - 'a' + 'A';
							}
						}

						fprintf(destSourceFile,"\t//all the game specific assets for %s\n#if FINALGAME == GAME_%s\n\n",FindFileData.cFileName,szCapitalDir.c_str());
					}
				}

				std::string szDirName = szDir;
				szDirName.append("/");
				szDirName.append(FindFileData.cFileName);
				ScanDirectory(szDirName.c_str(),false);

				//handle ifdef wrappers for packed textures
				if(bFirstDir)
				{
					//everyone but "Common" had an ifdef so we need to end it
					if(stricmp(FindFileData.cFileName,"Common"))
					{
						fprintf(destSourceFile,"#endif\n\n");
					}
				}
			}
		}
		while(FindNextFile(hFind,&FindFileData));
	}
}